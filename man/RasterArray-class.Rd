% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RasterArray-base.R
\docType{class}
\name{RasterArray-class}
\alias{RasterArray-class}
\alias{RasterArray}
\title{Virtual Array of RasterLayers}
\arguments{
\item{stack}{A \code{RasterStack} class object.}

\item{proxy}{A \code{vector}, \code{matrix} or \code{array} type object. Includes either the indices of layers in the stack, or their names.}

\item{dim}{A \code{numeric} vector. Same as for \code{array}, creates \code{proxy} procedurally.}
}
\description{
Array template for RasterLayers
}
\details{
The class implements structures to organize RasterLayers that have the same dimensions. Subsetting rules were defined using the proxy object in the \code{@index} slot. See examples for implementations.

The class has two slots:
stack: RasterStack, the actual data.
proxy: A proxy object that represents the organization of the layers.

Currently the following methods are implemented - documentation will come later:

show: type in the name to the console.

subset: needed for [

"[": behaves just like a matrix, or array. drop=TRUE keeps RasterArray, even if there is only one layer. x[i] doesn't yet work for multidimensional containers.

"[[": just like RasterStack

"colnames": names of the second dim.

"rownames":names of the first dim.

"dim": dimensions of the array. Unlike the method of RasterStack, this doesn't include the layer dimensions.

"dimlayer": dimensions of the RasterLayers.

"dimnames": Names in all dimensions. I am thinking about naming the dimensions in some way (e.g. time, depth, var), so we can do subsetting with them.

"nrow": Number of rows in the array. Unlike nrow for the RasterLayers.

"ncol": Number of columns in the array. Unlike ncol for the RasterLayers.
  
  "maxValue": outputs maximum value in RasterLayers - keeping the structure of proxy.
  
  "minValue": outputs minimum value in RasterLayers - keeping the structure of proxy.
  
  "res", "yres", "xres" are the same as for RasterStack.

There are only two contructor processes defined, these should get us through the initial developmental phases.
There is no validity testing yet, that is still to be implemented.
The plot method will be directed with the proxy object.
}
\examples{
# data import
  data(demo)
  st <-demo@stack

# class definition
  # 1d vector of rasters
  ind <- 1:3
  names(ind) <- names(st)
  
  first <- RasterArray(stack=st, index=ind)
  
  # 2d matrix of rasters
  ind2 <- matrix(1:6, ncol=2, nrow=3)
  rownames(ind2) <- names(st)
  colnames(ind2) <- c("orig", "plus")
  stPlus <- st+1
  
  second <- RasterArray(stack(st, stPlus), index=ind2)
  
  # 3d array of rasters
  ind3 <- array(1:prod(3,2,4), dim=c(3,2,4), dimnames=list(rownames(ind2), colnames(ind2), letters[1:4]))
  
  stA<- second@stack
  stB<- second@stack+100
  stC<- second@stack+200
  stD<- second@stack+300
  
  third <- RasterArray(stack(stA, stB,stC,stD), index=ind3)

# example subsetting
# one dimensional RasterArray
  # direct application, logical subsetting
  subset(first, c(TRUE, FALSE, TRUE))
  
  # access by index - dropping the structure
  first[3] 

  # acces by name - dropping strucutre
  first["X0"]
  first["X4"]
  
  # access by index - no drop
  first[3, drop=FALSE]
  # access by name, dropping
  first["X0", drop=FALSE]
  first["X4", drop=FALSE]


# two dimensional RasterArray
  second[1] # doesn't work - need fix
  second[,2] # second column
  
  # single element, 
  second["X0","orig"]
  second["X0","plus"]
  
  # single element, without dropping
  second["X0","orig", drop=FALSE]
  second["X0","plus", drop=FALSE]
  
  # list type access?
  second[[1]]

# three dimensional RasterArray
  third[1] # doesn't work - need fix!
  
  # first plane
  third[,,1]
  
  # second plane
  third[,,2]
  
  # first row-plane
  third[1,,]
  
  third[, 2,]
}
